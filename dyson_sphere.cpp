#include <iostream>
#include <vector>
#include <cmath>
#include <random>
#include <chrono>
#include <iomanip>
#include <fstream>
#include <string>
#include <map>
#include <algorithm>
#include <thread>
#include <signal.h>
#include <nlohmann/json.hpp>

using json = nlohmann::json;

namespace Constants {
    constexpr double G = 6.67430e-11;          // m³/(kg⋅s²)
    constexpr double c = 2.99792458e8;          // m/s
    constexpr double sigma = 5.670374419e-8;    // W/(m²⋅K⁴) Stefan-Boltzmann
    constexpr double AU = 1.495978707e11;       // m
    constexpr double k_B = 1.380649e-23;        // J/K Boltzmann constant
    constexpr double T_min = 2.7;               // K CMB temperature
}

namespace Solar {
    constexpr double mass = 1.989e30;           // kg
    constexpr double radius = 6.96e8;           // m
    constexpr double luminosity = 3.828e26;     // W
    constexpr double T_eff = 5772;              // K effective temperature
}

struct SwarmComponent {
    double area;                 // m² collector area
    double mass;                 // kg
    double absorptivity;         // e (0-1)
    double reflectivity;         // a (0-1) Bond albedo
    double transmittance;        // t (0-1)
    double emissivity_int;       // interior emissivity
    double emissivity_ext;       // exterior emissivity
    
    double orbit_radius;         // m
    double angular_position;     // radians
    double orbital_velocity;     // m/s
    double orbital_period;       // s
    double inclination;          // radians

    double T_interior;           // K interior temperature
    double T_exterior;           // K exterior temperature
    double thermal_mass;         // J/K

    double L_absorbed;           // W absorbed stellar power
    double L_reflected;          // W reflected stellar power
    double L_transmitted;        // W transmitted stellar power
    double L_thermal_int;        // W thermal emission interior
    double L_thermal_ext;        // W thermal emission exterior

    double degradation;          // 0-1 (0=perfect, 1=failed)
    double age;                  // years
    double radiation_damage;     // cumulative
    
    SwarmComponent(double collector_area, double radius, double e = 0.9, double a = 0.05, double t = 0.05)
        : area(collector_area), orbit_radius(radius), absorptivity(e), 
          reflectivity(a), transmittance(t), degradation(0.0), age(0.0),
          radiation_damage(0.0), angular_position(0.0), inclination(0.0) {
        
        // Physical constraints from Wright Eq. (24): a + t + e = 1
        double sum = absorptivity + reflectivity + transmittance;
        if (abs(sum - 1.0) > 0.01) {
            double scale = 1.0 / sum;
            absorptivity *= scale;
            reflectivity *= scale;
            transmittance *= scale;
        }
        
        // Mass estimation (assume thin solar panels ~10 kg/m²)
        mass = area * 10.0;
        thermal_mass = mass * 900.0;  // J/K (aluminum-like heat capacity)

        orbital_velocity = sqrt(Constants::G * Solar::mass / orbit_radius);
        orbital_period = 2.0 * M_PI * sqrt(pow(orbit_radius, 3) / (Constants::G * Solar::mass));

        T_interior = 300.0;
        T_exterior = 300.0;

        emissivity_int = absorptivity;
        emissivity_ext = 0.85;  
    }
};

class DysonSwarm {
private:
    std::vector<SwarmComponent> components;
    std::mt19937 rng;

    double swarm_radius;         // m
    double coverage_fraction;    // fraction of solid angle covered
    int num_components;
    double simulation_time;      // years
    double dt;                   // timestep in years

    double alpha;                // fraction of stellar luminosity absorbed
    double gamma;                // fraction emitted as thermal radiation
    double epsilon;              // energy generated by other means
    double nu;                   // fraction used for non-thermal work

    double L_star_surface;       // W actual stellar surface luminosity
    double L_star_intrinsic;     // W intrinsic stellar luminosity
    double f_star_absorbed;      // fraction of starlight absorbed by swarm
    double f_star_reflected;     // fraction of starlight reflected back to star
    double f_star_transmitted;   // fraction of starlight transmitted
    
public:
    DysonSwarm(double radius = Constants::AU, double coverage = 0.01, int components = 1000)
        : rng(std::chrono::steady_clock::now().time_since_epoch().count()),
          swarm_radius(radius), coverage_fraction(coverage), 
          num_components(components), simulation_time(0.0), dt(1.0/365.25/24.0) {

        epsilon = 0.0;  
        nu = 0.0;               
        L_star_intrinsic = Solar::luminosity;
        L_star_surface = Solar::luminosity;  
        
        initialize_swarm();
        calculate_system_properties();
    }
    
    void initialize_swarm() {
        components.clear();
        components.reserve(num_components);
        
        std::uniform_real_distribution<double> theta_dist(0.0, 2.0 * M_PI);
        std::uniform_real_distribution<double> cos_phi_dist(-1.0, 1.0);
        std::uniform_real_distribution<double> area_dist(500.0, 2000.0);

        double total_solid_angle = 4.0 * M_PI;
        double covered_solid_angle = total_solid_angle * coverage_fraction;
        double solid_angle_per_component = covered_solid_angle / num_components;
        
        for (int i = 0; i < num_components; i++) {
            double area = area_dist(rng);
            SwarmComponent comp(area, swarm_radius);

            comp.angular_position = theta_dist(rng);
            comp.inclination = acos(cos_phi_dist(rng));

            std::normal_distribution<double> var(0.0, 0.05);
            comp.absorptivity = std::max(0.1, std::min(0.95, comp.absorptivity + var(rng)));
            comp.reflectivity = std::max(0.01, std::min(0.3, comp.reflectivity + var(rng)));
            comp.transmittance = 1.0 - comp.absorptivity - comp.reflectivity;
            comp.transmittance = std::max(0.0, comp.transmittance);
            
            components.push_back(comp);
        }
    }
    
    void update_stellar_interaction(SwarmComponent& comp) {
        double flux = Solar::luminosity / (4.0 * M_PI * comp.orbit_radius * comp.orbit_radius);

        double cos_angle = std::max(0.0, cos(comp.inclination));
        double effective_flux = flux * cos_angle;

        double incident_power = comp.area * effective_flux;
        
        comp.L_absorbed = incident_power * comp.absorptivity * (1.0 - comp.degradation);
        comp.L_reflected = incident_power * comp.reflectivity;
        comp.L_transmitted = incident_power * comp.transmittance;

        double sigma_T4_int = Constants::sigma * pow(comp.T_interior, 4);
        comp.L_thermal_int = comp.area * comp.emissivity_int * sigma_T4_int * 0.5; 

        double sigma_T4_ext = Constants::sigma * pow(comp.T_exterior, 4);
        comp.L_thermal_ext = comp.area * comp.emissivity_ext * sigma_T4_ext * 0.5; 
    }
    
    void update_thermal_balance(SwarmComponent& comp) {
        double heat_in_int = comp.L_absorbed;
        double heat_out_int = comp.L_thermal_int;
        double conduction_to_ext = 1000.0 * (comp.T_interior - comp.T_exterior); // W simple conduction
        
        double dT_int_dt = (heat_in_int - heat_out_int - conduction_to_ext) / (comp.thermal_mass * 0.5);
        comp.T_interior += dT_int_dt * dt * 365.25 * 24 * 3600; 

        double heat_in_ext = conduction_to_ext;
        double heat_out_ext = comp.L_thermal_ext;
        double cmb_heating = comp.area * comp.emissivity_ext * Constants::sigma * 
                           (pow(Constants::T_min, 4) - pow(comp.T_exterior, 4));
        
        double dT_ext_dt = (heat_in_ext + cmb_heating - heat_out_ext) / (comp.thermal_mass * 0.5);
        comp.T_exterior += dT_ext_dt * dt * 365.25 * 24 * 3600;
        
        comp.T_interior = std::max(Constants::T_min, std::min(2000.0, comp.T_interior));
        comp.T_exterior = std::max(Constants::T_min, std::min(1000.0, comp.T_exterior));

        if (comp.T_interior > 400.0) {
            double temp_degradation = 0.001 * (comp.T_interior - 400.0) * dt;
            comp.degradation += temp_degradation;
        }
    }
    
    void update_orbital_dynamics(SwarmComponent& comp, const json& solar_data) {
        double distance = comp.orbit_radius;
        double grav_force = Constants::G * Solar::mass * comp.mass / (distance * distance);
        double grav_accel = grav_force / comp.mass; // = G*M/r^2

        double flux = Solar::luminosity / (4.0 * M_PI * distance * distance);
        double radiation_force = flux * comp.area / Constants::c; // F = P*A/c
        double rad_accel = radiation_force / comp.mass;

        double wind_pressure = 0.0;
        if (solar_data.contains("wind_pressure_Pa")) {
            wind_pressure = solar_data["wind_pressure_Pa"].get<double>();
        }
        double wind_force = wind_pressure * comp.area;
        double wind_accel = wind_force / comp.mass;

        double orbital_speed = sqrt(Constants::G * Solar::mass / distance);
        double centripetal_accel = orbital_speed * orbital_speed / distance;

        double net_accel = rad_accel + wind_accel - centripetal_accel;

        double orbit_control = 0.0;
        if (solar_data.contains("orbit_delta")) {
            orbit_control = solar_data["orbit_delta"].get<double>(); // -1 to +1
        }

        double control_thrust = orbit_control * 1e-6; 
        net_accel += control_thrust;

        double time_scale = 365.25 * 24 * 3600; // 1 year in seconds
        double dt_seconds = dt * time_scale;

        double delta_v = net_accel * dt_seconds;
        double new_radius = distance + delta_v * dt_seconds;

        double min_radius = 0.1 * Constants::AU; 
        double max_radius = 10.0 * Constants::AU; 
        comp.orbit_radius = std::max(min_radius, std::min(max_radius, new_radius));

        comp.orbital_velocity = sqrt(Constants::G * Solar::mass / comp.orbit_radius);
        comp.orbital_period = 2.0 * M_PI * sqrt(pow(comp.orbit_radius, 3) / 
                                               (Constants::G * Solar::mass));

        double angular_velocity = comp.orbital_velocity / comp.orbit_radius;
        comp.angular_position += angular_velocity * dt_seconds;

        if (comp.angular_position > 2.0 * M_PI) {
            comp.angular_position -= 2.0 * M_PI;
        }
    }

    double calculate_orbital_stability(const SwarmComponent& comp) {
        double distance = comp.orbit_radius;

        double v_ideal = sqrt(Constants::G * Solar::mass / distance);

        double v_current = comp.orbital_velocity;

        double velocity_ratio = std::min(v_current, v_ideal) / std::max(v_current, v_ideal);
        
        return velocity_ratio;
    }

    void add_orbital_perturbations(SwarmComponent& comp, double dt) {
        static std::mt19937 rng(std::chrono::steady_clock::now().time_since_epoch().count());
        std::normal_distribution<double> wind_var(1.0, 0.1); // ±10% variation
        double wind_multiplier = wind_var(rng);
        
        double grav_perturbation = 1e-12 * sin(comp.angular_position * 7.3); 

        double thermal_thrust = comp.L_thermal_ext / (Constants::c * comp.mass);

        double total_perturbation = wind_multiplier + grav_perturbation + thermal_thrust;
        comp.orbit_radius *= (1.0 + total_perturbation * dt * 1e-6);
    }
    
    void update_degradation(SwarmComponent& comp, const json& solar_data) {
        double base_degradation_rate = 0.005; // per year
        comp.degradation += base_degradation_rate * dt;

        if (solar_data.contains("solar_flare_active") && 
            solar_data["solar_flare_active"].get<double>() > 0.5) {
            comp.radiation_damage += 0.001;
            comp.degradation += 0.0001;
        }

        if (solar_data.contains("cme_active") && 
            solar_data["cme_active"].get<double>() > 0.5) {
            comp.radiation_damage += 0.005;
            comp.degradation += 0.0005;
        }

        comp.age += dt;
        if (comp.age > 25.0) { 
            comp.degradation += 0.01 * dt * (comp.age - 25.0);
        }

        comp.degradation = std::min(0.95, comp.degradation);
    }
    
    void calculate_system_properties() {
        double total_stellar_incident = 0.0;
        double total_absorbed = 0.0;
        double total_reflected = 0.0;
        double total_transmitted = 0.0;
        double total_thermal = 0.0;
        
        for (const auto& comp : components) {
            double incident = Solar::luminosity / (4.0 * M_PI * comp.orbit_radius * comp.orbit_radius) * comp.area;
            total_stellar_incident += incident;
            total_absorbed += comp.L_absorbed;
            total_reflected += comp.L_reflected;
            total_transmitted += comp.L_transmitted;
            total_thermal += comp.L_thermal_int + comp.L_thermal_ext;
        }

        f_star_absorbed = total_absorbed / Solar::luminosity;
        f_star_reflected = total_reflected / Solar::luminosity;
        f_star_transmitted = total_transmitted / Solar::luminosity;
        
        alpha = f_star_absorbed;
        gamma = total_thermal / Solar::luminosity;

        double reflection_feedback = 1.0 + f_star_reflected * 0.5; 
        L_star_surface = L_star_intrinsic * reflection_feedback;
    }
    
    void step(double timestep_years = 1.0/365.25) { 
        dt = timestep_years;
        simulation_time += dt;

        std::ifstream solar_file("solar_realtime.json");
        json solar_data;
        if (solar_file.is_open()) {
            solar_file >> solar_data;
            solar_file.close();
        }

        std::ifstream control_file("control_commands.json");
        json control_data;
        if (control_file.is_open()) {
            control_file >> control_data;
            for (auto& [key, value] : control_data.items()) {
                solar_data[key] = value;
            }
            control_file.close();
        }

        for (auto& comp : components) {
            update_stellar_interaction(comp);
            update_thermal_balance(comp);
            update_orbital_dynamics(comp, solar_data); 
            add_orbital_perturbations(comp, dt);       
            update_degradation(comp, solar_data);

            double stability = calculate_orbital_stability(comp);
            if (stability < 0.8) {
                // Component is becoming unstable - maybe trigger control response
            }
        }

        calculate_system_properties();
        export_data();
    }
    
    json get_status() const {
        json status;
        
        status["simulation_time_years"] = simulation_time;
        status["num_components"] = num_components;
        status["swarm_radius_AU"] = swarm_radius / Constants::AU;
        status["coverage_fraction"] = coverage_fraction;
        
        status["alpha"] = alpha;
        status["gamma"] = gamma;
        status["epsilon"] = epsilon;
        status["nu"] = nu;

        status["L_star_intrinsic_W"] = L_star_intrinsic;
        status["L_star_surface_W"] = L_star_surface;
        status["stellar_feedback_factor"] = L_star_surface / L_star_intrinsic;
        
        double total_power_absorbed = 0.0;
        double total_thermal_emission = 0.0;
        double avg_temp_int = 0.0;
        double avg_temp_ext = 0.0;
        double avg_degradation = 0.0;
        int failed_components = 0;
        
        for (const auto& comp : components) {
            total_power_absorbed += comp.L_absorbed;
            total_thermal_emission += comp.L_thermal_int + comp.L_thermal_ext;
            avg_temp_int += comp.T_interior;
            avg_temp_ext += comp.T_exterior;
            avg_degradation += comp.degradation;
            
            if (comp.degradation > 0.5) failed_components++;
        }
        
        status["total_power_absorbed_W"] = total_power_absorbed;
        status["total_thermal_emission_W"] = total_thermal_emission;
        status["thermodynamic_efficiency"] = 1.0 - (total_thermal_emission / std::max(1.0, total_power_absorbed));
        status["avg_interior_temp_K"] = avg_temp_int / components.size();
        status["avg_exterior_temp_K"] = avg_temp_ext / components.size();
        status["avg_degradation"] = avg_degradation / components.size();
        status["failure_rate"] = double(failed_components) / components.size();
        status["operational_components"] = num_components - failed_components;
        
        double T_avg_ext = avg_temp_ext / components.size();
        double theoretical_efficiency = 1.0 - (4.0/3.0) * Constants::T_min / Solar::T_eff;
        double practical_efficiency = 1.0 - T_avg_ext / Solar::T_eff;
        status["theoretical_max_efficiency"] = theoretical_efficiency;
        status["practical_efficiency"] = practical_efficiency;
        
        return status;
    }
    
    void export_data() const {
        std::ofstream status_file("dyson_status.json");
        status_file << std::setw(2) << get_status() << std::endl;
        status_file.close();

        json components_data = json::array();
        for (size_t i = 0; i < components.size(); i++) {
            const auto& comp = components[i];
            json comp_data;
            
            comp_data["id"] = i;
            comp_data["area"] = comp.area;
            comp_data["orbit_radius"] = comp.orbit_radius;
            comp_data["T_interior"] = comp.T_interior;
            comp_data["T_exterior"] = comp.T_exterior;
            comp_data["L_absorbed"] = comp.L_absorbed;
            comp_data["L_thermal_total"] = comp.L_thermal_int + comp.L_thermal_ext;
            comp_data["degradation"] = comp.degradation;
            comp_data["age_years"] = comp.age;
            comp_data["absorptivity"] = comp.absorptivity;
            comp_data["reflectivity"] = comp.reflectivity;
            comp_data["transmittance"] = comp.transmittance;
            comp_data["angular_position"] = comp.angular_position;
            comp_data["inclination"] = comp.inclination;
            
            components_data.push_back(comp_data);
        }
        
        std::ofstream components_file("dyson_components.json");
        components_file << std::setw(2) << components_data << std::endl;
        components_file.close();

        std::ofstream stream_file("dyson_stream.txt");
        auto status = get_status();
        stream_file << std::fixed << std::setprecision(6)
                    << simulation_time << " "
                    << status["total_power_absorbed_W"].get<double>() << " "
                    << status["total_thermal_emission_W"].get<double>() << " "
                    << status["thermodynamic_efficiency"].get<double>() << " "
                    << status["alpha"].get<double>() << " "
                    << status["gamma"].get<double>() << std::endl;
        stream_file.close();
    }
};

volatile sig_atomic_t keep_running = 1;
void signal_handler(int signal) {
    keep_running = 0;
    std::cout << "\nDyson Swarm simulation stopping...\n";
}

int main(int argc, char* argv[]) {
    signal(SIGINT, signal_handler);
    
    double radius = Constants::AU;
    double coverage = 0.01;
    int components = 1000;
    
    if (argc > 1) radius = std::stod(argv[1]) * Constants::AU;
    if (argc > 2) coverage = std::stod(argv[2]);
    if (argc > 3) components = std::stoi(argv[3]);
    
    std::cout << "DYSON SWARM SIMULATION (Wright 2020)\n";
    std::cout << "====================================\n";
    std::cout << "Radius: " << radius/Constants::AU << " AU\n";
    std::cout << "Coverage: " << coverage*100 << "%\n";
    std::cout << "Components: " << components << "\n";
    std::cout << "Based on Wright (2020) theoretical framework\n\n";
    
    DysonSwarm swarm(radius, coverage, components);
    
    while (keep_running) {
        auto start = std::chrono::high_resolution_clock::now();
        
        swarm.step(1.0/365.25/24.0);
        
        auto status = swarm.get_status();

        std::cout << "T+" << std::setw(8) << std::fixed << std::setprecision(3) 
                  << status["simulation_time_years"].get<double>() << "yr | "
                  << "α=" << std::setprecision(4) << status["alpha"].get<double>() << " | "
                  << "γ=" << status["gamma"].get<double>() << " | "
                  << "η=" << status["thermodynamic_efficiency"].get<double>() << " | "
                  << "T̄=" << std::setprecision(0) << status["avg_exterior_temp_K"].get<double>() << "K | "
                  << "Fail:" << std::setprecision(1) << status["failure_rate"].get<double>()*100 << "%   \r" << std::flush;

        auto end = std::chrono::high_resolution_clock::now();
        auto elapsed = std::chrono::duration_cast<std::chrono::milliseconds>(end - start);
        auto sleep_time = std::chrono::milliseconds(100) - elapsed; // 10Hz update rate
        if (sleep_time.count() > 0) {
            std::this_thread::sleep_for(sleep_time);
        }
    }
    
    std::cout << "\n\nFinal Dyson Swarm Status (Wright 2020 Parameters):\n";
    auto final_status = swarm.get_status();
    std::cout << "- α (absorbed fraction): " << std::fixed << std::setprecision(4)
              << final_status["alpha"].get<double>() << "\n";
    std::cout << "- γ (thermal emission fraction): " 
              << final_status["gamma"].get<double>() << "\n";
    std::cout << "- Thermodynamic efficiency: " 
              << final_status["thermodynamic_efficiency"].get<double>() << "\n";
    std::cout << "- Average exterior temperature: " << std::setprecision(0)
              << final_status["avg_exterior_temp_K"].get<double>() << " K\n";
    std::cout << "- Theoretical max efficiency: " << std::setprecision(4)
              << final_status["theoretical_max_efficiency"].get<double>() << "\n";
    std::cout << "- Component failure rate: " << std::setprecision(1)
              << final_status["failure_rate"].get<double>()*100 << "%\n";
    std::cout << "- Data exported to: dyson_status.json, dyson_components.json\n";
    
    return 0;
}